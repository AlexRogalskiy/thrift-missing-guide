Here is a pictorial view of the Thrift network stack:

["ditaa"]
.The Thrift Network Stack
-----------------------------------------------------------------------------
+-------------------------------------------+
| cGRE                                      |
| Server                                    |
| (single-threaded, event-driven etc)       |
+-------------------------------------------+
| cBLU                                      |
| Processor                                 |
| (compiler generated)                      |
+-------------------------------------------+
| cGRE                                      |
| Protocol                                  |
| (JSON, compact etc)                       |
+-------------------------------------------+
| cGRE                                      |
| Transport                                 |
| (raw TCP, HTTP etc)                       |
+-------------------------------------------+
-----------------------------------------------------------------------------

Transport
^^^^^^^^^

The Transport layer provides a simple abstraction for reading/writing from/to
the network. This enables Thrift to decouple the underlying transport from the
rest of the system (serialization/deserialization, for instance).

Here are some of the methods exposed by the +Transport+ interface:

* +open+
* +close+
* +read+
* +write+
* +flush+

In addition to the +Transport+ interface above, Thrift also uses a
+ServerTransport+ interface used to accept or create primitive transport
objects. As the name suggest, +ServerTransport+ is used mainly on the server
side to create new Transport objects for incoming connections.

* +open+
* +listen+
* +accept+
* +close+

Protocol
^^^^^^^^

The Protocol abstraction defines a mechanism to map in-memory data structures to
a wire-format. In other words, a protocol specifies how datatypes use the
underlying Transport to encode/decode themselves.  Thus the protocol
implementation governs the encoding scheme and is responsible for
(de)serialization. Some examples of protocols in this sense include JSON, XML,
plain text, compact binary etc.

Here is the +Protocol+ interface:
[source,cpp]
-----------------------------------------------------------------------------
writeMessageBegin(name, type, seq)
writeMessageEnd()
writeStructBegin(name)
writeStructEnd()
writeFieldBegin(name, type, id)
writeFieldEnd()
writeFieldStop()
writeMapBegin(ktype, vtype, size)
writeMapEnd()
writeListBegin(etype, size)
writeListEnd()
writeSetBegin(etype, size)
writeSetEnd()
writeBool(bool)
writeByte(byte)
writeI16(i16)
writeI32(i32)
writeI64(i64)
writeDouble(double)
writeString(string)

name, type, seq = readMessageBegin()
                  readMessageEnd()
name = readStructBegin()
       readStructEnd()
name, type, id = readFieldBegin()
                 readFieldEnd()
k, v, size = readMapBegin()
             readMapEnd()
etype, size = readListBegin()
              readListEnd()
etype, size = readSetBegin()
              readSetEnd()
bool = readBool()
byte = readByte()
i16 = readI16()
i32 = readI32()
i64 = readI64()
double = readDouble()
string = readString()
-----------------------------------------------------------------------------

Thrift Protocols are stream oriented by design. There is no need for any
explicit framing. For instance, it is not necessary to know the length of a
string or the number of items in a list before we start serializing them.

Processor
^^^^^^^^^

A Processor encapsulates the ability to read data from input streams and write
to output streams. The input and output streams are represented by Protocol
objects. The Processor interface is extremely simple:

[source,java]
-----------------------------------------------------------------------------
interface TProcessor {
    bool process(TProtocol in, TProtocol out) throws TException
}
-----------------------------------------------------------------------------

Service-specific processor implementations are generated by the compiler. The
Processor essentially reads data from the wire (using the input protocol),
delegates processing to the handler (implemented by the user) and writes the
response over the wire (using the output protocol).

Server
^^^^^^

A Server pulls together all of the various features described above:

* Create a transport
* Create input/output protocols for the transport
* Create a processor based on the input/output protocols
* Wait for incoming connections and hand them off to the processor

Next we discuss the generated code for specific languages. Unless mentioned
otherwise, the sections below will assume the following Thrift specification:

[source,cpp]
.Example IDL
-----------------------------------------------------------------------------
include::example.thrift[]
-----------------------------------------------------------------------------

